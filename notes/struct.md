# 字段

首字母大写表示可导出（可被其它包访问）

```go
type A struct{
  Name string
  age int 
}
```



# 结构体比较

+ 如果所有字段都可比较，则结构体可比较

+ 可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型





# 结构体嵌套和匿名成员

go允许我们定义不带名称的结构体成员，只需要指定类型即可；这种结构体成员称作匿名成员。这个结构体成员的类型必须是一个命名类型或者指向命名类型的指针

实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法



# Tag







# 指针成员

+ 类型递归

一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适用于数组。）但是S类型的结构体可以包含`*S`指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等



# 方法

+ 方法接收者可以是类型T 或类型指针 *T

实参接收者和形参接收者是同一类型，比如都是T或者都是*T。（1，4，5，7）

实参接收者是T类型的***变量\***而形参接收者是*T类型，编译器会隐式的获取变量的地址（3）。

实参接收者是*T类型而形参接收者是T类型，编译器会隐式的获取实际的取值。（2，6）
 其中8编译过程报错的原因是：编译器对T类型转化为*T类型的隐式转化，只有实参接收者是变量才可以成功，因为无法获取临时变量的地址。

```go
type Point struct {
    X int
    Y int
}
func (p Point) Print() {
    fmt.Println(p.X, p.Y)
}
func (p *Point) ScaleBy(factor int) {
    p.X *= factor
    p.Y *= factor
}
func main() {
    p := Point{1,1}
    ptr := &p
    p.Print()   //1. 正确
    ptr.Print() //2. 正确
    p.ScaleBy(2)      //3. 正确
    ptr.ScaleBy(2)    //4. 正确
    Point{1,1}.Print()    //5. 正确
    (&Point{1,1}).Print() //6. 正确
    (&Point{1,1}).ScaleBy( 2) //7. 正确
    Point{1,1}.ScaleBy( 2)    //8. 错误
}
```

- *nil是一个合法的接收者：就像一些函数允许nil指针作为实参，方法的接收者允许是nil指针*



# 空结构体

如果结构体没有任何成员的话就是空结构体，写作struct{}。它的大小为0，也不包含任何信息，但是有时候依然是有价值的。有些Go语言程序员用map来模拟set数据结构时，用它来代替map中布尔类型的value

